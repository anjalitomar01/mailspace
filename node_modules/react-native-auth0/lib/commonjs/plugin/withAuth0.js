"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.addIOSAuth0ConfigInInfoPList = exports.addAuth0AppDelegateCode = exports.addAndroidAuth0Manifest = void 0;
var _configPlugins = require("expo/config-plugins");
var _generateCode = require("./generateCode");
let APPLICATION_ID_SUFFIX = '.auth0';
let pkg = {
  name: 'react-native-auth0'
};
try {
  pkg = require('react-native-auth0/package.json');
} catch {
  // empty catch block
}
const addAndroidAuth0Manifest = (auth0Configs, manifest, applicationId) => {
  if (auth0Configs.length === 0) {
    throw new Error(`No auth0 domain specified in expo config`);
  }
  const intentFilterContent = [{
    action: [{
      $: {
        'android:name': 'android.intent.action.VIEW'
      }
    }],
    category: [{
      $: {
        'android:name': 'android.intent.category.DEFAULT'
      }
    }, {
      $: {
        'android:name': 'android.intent.category.BROWSABLE'
      }
    }],
    data: []
  }];
  const mainApplication = _configPlugins.AndroidConfig.Manifest.getMainApplicationOrThrow(manifest.modResults);
  _configPlugins.AndroidConfig.Manifest.ensureToolsAvailable(manifest.modResults);

  // Ensure RedirectActivity exists
  let redirectActivity = mainApplication.activity?.find(activity => activity.$['android:name'] === 'com.auth0.android.provider.RedirectActivity');
  if (!redirectActivity) {
    redirectActivity = {
      '$': {
        'android:name': 'com.auth0.android.provider.RedirectActivity',
        'tools:node': 'replace',
        'android:exported': 'true'
      },
      'intent-filter': intentFilterContent
    };
    mainApplication.activity = mainApplication.activity || [];
    mainApplication.activity.push(redirectActivity);
  }
  redirectActivity['intent-filter'] = redirectActivity['intent-filter'] || intentFilterContent;
  const intentFilter = redirectActivity['intent-filter'][0] || {};
  intentFilter.data = intentFilter.data || [];

  // Add data elements for each auth0Config
  auth0Configs.forEach(config => {
    if (config.domain == null) {
      throw new Error(`No auth0 domain specified in expo config`);
    }
    if (config.customScheme == null && applicationId == null) {
      throw new Error(`No auth0 scheme specified or package found in expo config`);
    }
    let auth0Scheme = config.customScheme ?? applicationId + APPLICATION_ID_SUFFIX;
    const dataElement = {
      $: {
        'android:scheme': auth0Scheme,
        'android:host': config.domain
      }
    };
    intentFilter.data?.push(dataElement);
  });
  return manifest;
};
exports.addAndroidAuth0Manifest = addAndroidAuth0Manifest;
const withAndroidAuth0Manifest = (config, auth0Configs) => {
  let applicationId = config.android?.package;
  return (0, _configPlugins.withAndroidManifest)(config, manifest => {
    return addAndroidAuth0Manifest(auth0Configs, manifest, applicationId);
  });
};
const addAuth0AppDelegateCode = src => {
  let tempSrc = src;
  // Tests to see if the RCTLinkingManager has already been added
  if (!/\[RCTLinkingManager.*application:.*openURL:.*options:.*\]/.test(tempSrc)) {
    tempSrc = (0, _generateCode.mergeContents)({
      src: tempSrc,
      newSrc: ['- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url', '            options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options', '{', '  return [RCTLinkingManager application:app openURL:url options:options];', '}'].join('\n'),
      tag: 'react-native-auth0-linking',
      anchor: /@end/,
      comment: '//',
      offset: 0
    }).contents;
  }
  // Checks to see if RCTLinkingManager hasn't been imported
  if (!/RCTLinkingManager\.h/.test(tempSrc)) {
    tempSrc = (0, _generateCode.mergeContents)({
      src: tempSrc,
      newSrc: `#import <React/RCTLinkingManager.h>`,
      anchor: /#import <React\/RCTBridge\.h>/,
      offset: 1,
      tag: 'react-native-auth0-import',
      comment: '//'
    }).contents;
  }
  return tempSrc;
};
exports.addAuth0AppDelegateCode = addAuth0AppDelegateCode;
const withIOSAuth0AppDelegate = config => {
  return (0, _configPlugins.withAppDelegate)(config, config => {
    const src = config.modResults.contents;
    config.modResults.contents = addAuth0AppDelegateCode(src);
    return config;
  });
};
const withIOSAuth0InfoPList = (config, props) => {
  return (0, _configPlugins.withInfoPlist)(config, config => {
    return addIOSAuth0ConfigInInfoPList(props, config);
  });
};
const addIOSAuth0ConfigInInfoPList = (props, config) => {
  let customSchemes = props.filter(prop => prop.customScheme != null).map(prop => prop.customScheme);
  let bundleIdentifier;
  if (config.ios?.bundleIdentifier) {
    bundleIdentifier = config.ios?.bundleIdentifier + APPLICATION_ID_SUFFIX;
  }
  if (customSchemes.length === 0) {
    if (bundleIdentifier == null) {
      throw Error('No auth0 scheme specified or bundle identifier found in expo config');
    } else {
      customSchemes = [bundleIdentifier];
    }
  }
  let urlTypes = config.modResults.CFBundleURLTypes || [];
  customSchemes.forEach(scheme => {
    if (urlTypes.some(({
      CFBundleURLSchemes
    }) => CFBundleURLSchemes.includes(scheme))) {
      return;
    }
    const existingAuth0URLType = urlTypes.find(urlType => urlType.CFBundleURLName === 'auth0');
    if (existingAuth0URLType) {
      // Add the scheme to the existing CFBundleURLSchemes array
      existingAuth0URLType.CFBundleURLSchemes.push(scheme);
    } else {
      // Add a new object
      urlTypes.push({
        CFBundleURLName: 'auth0',
        CFBundleURLSchemes: [scheme]
      });
    }
  });
  config.modResults.CFBundleURLTypes = urlTypes;
  return config;
};
exports.addIOSAuth0ConfigInInfoPList = addIOSAuth0ConfigInInfoPList;
const withAuth0 = (config, props) => {
  const auth0PluginConfigs = Array.isArray(props) ? props : [props];
  config = withAndroidAuth0Manifest(config, auth0PluginConfigs);
  config = withIOSAuth0AppDelegate(config, auth0PluginConfigs);
  config = withIOSAuth0InfoPList(config, auth0PluginConfigs);
  return config;
};
var _default = exports.default = (0, _configPlugins.createRunOncePlugin)(withAuth0, pkg.name, pkg.version);
//# sourceMappingURL=withAuth0.js.map